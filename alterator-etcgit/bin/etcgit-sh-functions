#!/bin/sh

LOCALDIR=.etcgit
PERMS=$LOCALDIR/file-permissions
FILTERSDIR=$LOCALDIR/filters
PUBDIR=/srv/git/pub/etc.git

_cd_init() {
	cd "$1"
	[ -d .git ] || git init 1>/dev/null 2>&1
        [ -d $LOCALDIR ] || mkdir $LOCALDIR
}

_cd_if_git() {
	[ -d "${1%/}/.git" ] && cd "$1" || return 1
        [ -d $LOCALDIR ] || mkdir $LOCALDIR
}

_get_branch_name() {
	git branch | sed -n -e 's/^\*[[:space:]]\+//p'
}

get_branch_name() {
	(
		_cd_if_git /etc || return 0
		_get_branch_name
	)
}

_get_branch_remote_url() {
	local br="$1"

	[ -z "$br" ] && br="$(_get_branch_name)"
	git config "branch.$br.remote"
}

get_branch_remote_url() {
        local br="${1-}"

        (
		_cd_if_git /etc || return 0
		_get_branch_remote_url "$br"
        )
}

_get_remote_branch_status() {
        local url="${1-$(_get_branch_remote_url)}"
        local br="${2-$(_get_branch_name)}"
        [ -n "$url" ] && [ -n "$br" ] || return 1
        local lhd=$(_get_branch_head "$br")
        local rhd=$(_get_remote_branch_head "$url" "$br")
        local status=

        if [ -n "$lhd" ] && [ -n "$rhd" ]; then
                status=$(_compare_heads $rhd $lhd)
        elif [ -n "$lhd" ]; then
                status='nw'
        elif [ -n "$rhd" ]; then
                status='lo'
        else
                status='un'
        fi

        echo "$status"
}

_fetch_remote_branch() {
        local url="${1-$(_get_branch_remote_url)}"
        local br="${2-$(_get_branch_name)}"
        local ret=0

        [ -n "$url" ] && [ -n "$br" ] || return 1

        case "$(_get_remote_branch_status "$url" "$br")" in
                lo|fr)
                        if [ "$br" != "$(_get_branch_name)" ]; then
                                git fetch "$url" "$br:$br" 1>/dev/null 2>&1
                                ret=$?
                        else
                                git fetch "$url" "$br" 1>/dev/null 2>&1
                                ret=$?
                                if [ $ret -eq 0 ]; then
                                        git reset $(_get_remote_branch_head "$url" "$br") 1>/dev/null 2>&1
                                        ret=$?
                                fi
                        fi
                        ;;
                eq)
                        ret=0
                        ;;
                *)
                        ret=1
                        ;;
        esac

        if [ $ret -eq 0 ]; then
                git config "branch.$br.remote" "$url"
        fi

        return $ret
}

fetch_remote_branch() {
        local url="${1-${in_url-$(get_branch_remote_url)}}"
        local br="${2-${in_branch-}}"

        (
                _cd_init /etc || return 1
                _fetch_remote_branch "$url" "$br"
        )
}

_delete_branch() {
        local br="$1"

        [ -n "$br" ] || return 0
        if [ "$br" = "$(_get_branch_name)" ]; then
                git checkout --detach "$br"
        fi
        git branch -D "$br" 1>/dev/null 2>&1 || return 1
        _publish_branch "$br" || return 2
}

delete_branch() {
        local br="${1-${in_branch-}}"

        (
                _cd_if_git /etc || return 0
                _delete_branch "$br"
        )
}

_list_local_branches() {
        git show-ref --heads | \
                while read head name; do
                        printf '%s\t%s\t%s\n' "${name##*/}" "$head" "$(_get_branch_remote_url "${name##*/}")"
                done
}

list_local_branches() {
	(
		_cd_if_git /etc || return 0
                _list_local_branches
	)
}

_count_ancestry_path() {
        local path="$1"

        git log --ancestry-path "$path" | wc -l
}

_compare_heads() {
        local hda="$1"
        local hdb="$2"

        if [ "$hda" = "$hdb" ]; then
                echo 'eq'
        elif [ $(_count_ancestry_path "$hda..$hdb") -gt 0 ]; then
                echo 'ff'
        elif [ $(_count_ancestry_path "$hdb..$hda") -gt 0 ]; then
                echo 'fr'
        else
                echo 'br'
        fi
}

list_remote_branches() {
        local url="${1-${in_url-$(get_branch_remote_url)}}"

        (
                _cd_init /etc || return 1
                _list_remote_branches "$url"
        )
}

_get_remote_branch_head() {
        local url="${1-$(_get_branch_remote_url)}"
        local br="${2-$(_get_branch_name)}"

        git ls-remote --heads "$url" "$br" | sed -e 's,[[:space:]]\+refs/heads/.\+$,,'
}

_list_remote_branches() {
        local url="${1-$(_get_branch_remote_url)}"

	git ls-remote --heads "$url" | \
                while read rhd rbr; do
                        rbr=${rbr##*/}
                        lhd=$(_get_branch_head $rbr)
                        if [ -n "$lhd" ]; then
                                printf '%s\t%s\t%s\t%s\n' $rbr $rhd $lhd $(_compare_heads $lhd $rhd)
                        else
                                printf '%s\t%s\t%s\t%s\n' $rbr $rhd '0' 'nw'
                        fi
                done
}

_reset_branch() {
        local hd="$1"
        [ -n "$hd" ] || return 0

        git reset "$hd" 1>/dev/null 2>&1
}

reset_branch() {
        local hd="${1-$in_commit}"
        [ -n "$hd" ] || return 0

        (
                _cd_if_git /etc || return 0
                _reset_branch "$hd"
        )
}

_step_path_dirs() {
        sed -n -e ':b H; s,/[^/]\+$,,; t b; z; x; p; d' | sed -e '/^$/ d' | LC_ALL=C sort -u
}

_dump_file_permissions() {
        stat -c '%n 0%a:%U:%G' $(find $(git ls-files) -type f 2>/dev/null | _step_path_dirs) 2>/dev/null ||:
}

_apply_file_permissions() {
        eval "$(sed -e 's/^\(.*\) \(0[0-7][0-7][0-7]\):\([^:]\+\):\([^:]\+\)$/[ -h \1 ] || chown \3:\4 \1\n[ -h \1 ] || chmod \2 \1/')"
}

_list_modified() {
        local br="${1-${in_branch-$(get_branch_name)}}"
	(
		_cd_if_git /etc || return 0
                [ -e .gitignore ] && git add . 1>/dev/null 2>&1
                _dump_file_permissions >$PERMS
                git add -f $PERMS 1>/dev/null 2>&1
                git diff --name-status "$br" 2>/dev/null
                git reset . 1>/dev/null 2>&1
	)
}

_list_K() {
        local rcd="$1"

        find "$rcd" -name 'K*' | \
        sed -e 's,^.*\(K[0-9]\+[^/]\+\)$,\1,' | \
	sort
}

_get_runlevel() {
        runlevel | sed -n 's/^.*\([0-9]\+\)$/\1/p'
}

_get_linked_srv() {
        local srv="$(readlink "$1")"

        echo "${srv##*/}"
}

_list_rS() {
        local rcd="$1"

        find "$rcd" -name 'S*' | \
        sed -e 's,^.*\(S[0-9]\+[^/]\+\)$,\1,' | \
	sort -r
}

_in_list() {
        local key="$1"; shift
        [ $# -gt 0 ] || return 1

        for k in "$@"; do
                [ "$k" != "$key" ] || return 0
        done

        return 1
}

_srv_is_independent() {
        local srv="$1"; shift

        if _in_list 'network' "$@"; then
                case "$srv" in
                        ahttpd)
                                return 1
                                ;;
                esac
        fi

	case "$srv" in
		ahttpd|alteratord|plymouth|local|irqbalance|mdadm|random|udevd|udevd-final|fbsetfont|consolesaver|keytable|gpm)
			return 0
			;;
		*)
			return 1
			;;
	esac
}

list_kill_seq_for_srv() {
        local srvname="${1:-$in_service}"
        local runlevel="$(_get_runlevel)"
        [ -n "$runlevel" ] || runlevel=3
        local rcd="/etc/rc.d/rc$runlevel.d"
        [ -d "$rcd" ] || return 2
        local klist="$(_list_rS "$rcd")"
        local ksrvlist="$(for f in $klist; do ksrv="$(_get_linked_srv "$rcd/$f")"; echo "$ksrv"; [ "$ksrv" != "$srvname" ] || break; done)"

	local ksrvname=
        for f in $klist; do
		ksrvname="$(_get_linked_srv "$rcd/$f")"
		[ "$ksrvname" != "$srvname" ] && _srv_is_independent "$ksrvname" $ksrvlist && continue
                echo "$f"
                [ "$ksrvname" != "$srvname" ] || break
        done
}

_list_S() {
        local rcd="$1"

        find "$rcd" -name 'S*' | \
        sed -e 's,^.*\(S[0-9]\+[^/]\+\)$,\1,' | \
	sort
}

_srv_is_on() {
        local srv="$1"
        local runlevel=${2-$(_get_runlevel)}

        chkconfig --level $runlevel "$srv" 1>/dev/null 2>&1
}

list_start_seq_for_srv() {
        local srvname="${1:-$in_service}"
        local runlevel="$(_get_runlevel)"
        [ -n "$runlevel" ] || runlevel=3
        local rcd="/etc/rc.d/rc$runlevel.d"
        [ -d "$rcd" ] || return 2
	local killseq="${2:-$(list_kill_seq_for_srv "$srvname" | _filter_SK)}"
	[ -n "$killseq" ] || return 0

	local ssrvname=
        for f in `_list_S "$rcd"`; do
		ssrvname="$(_get_linked_srv "$rcd/$f")"
                _in_list "$ssrvname" $killseq || continue
                _srv_is_on "$ssrvname" $runlevel || continue
                echo "$f"
        done
}

_special_services() {
    [ -n "$*" ] || return 0
    for f in "$@"; do
	case "$f" in
	    /etc/resolv.conf)
		echo "network"
		;;
	esac
    done | uniq
}

_get_service_names_for_files() {
	[ -n "$*" ] || return 0
        rpm -qfl "$@" 2>/dev/null | \
        sed -n -e '/^\/etc\/init.d\/functions$/ d' \
               -e '/^\/etc\/rc.d\/init.d\/functions$/ d' \
               -e '/^\/etc\/init.d\/[^\/]\+$/ s/^.*\///p' \
               -e '/^\/etc\/rc.d\/init.d\/[^\/]\+$/ s/^.*\///p' | \
        uniq
	_special_services "$@"
}

_filter_SK() {
        sed -e 's/^[SK][0-9]\+//'
}

list_modified() {
	_list_modified | \
	sed -e 's/^[[:space:]]*[^[:space:]]\+[[:space:]]\+//' \
	    -e 's,^.*$,/etc/&,'
}

list_modified_with_dirs() {
	_list_modified | \
        _step_path_dirs | \
	sed -e 's/^[[:space:]]*[^[:space:]]\+[[:space:]]\+//' \
	    -e 's,^.*$,/etc/&,'
}

list_kill_seq() {
	local srvs="${1-$(_get_service_names_for_files $(list_modified_with_dirs))}"

	for s in $srvs; do
                list_kill_seq_for_srv "$s"
        done | \
        sort -ru | \
        _filter_SK
}

list_start_seq() {
	local srvs="${1-$(_get_service_names_for_files $(list_modified_with_dirs))}"
	local killseq="${2-}"

	for s in $srvs; do
                list_start_seq_for_srv "$s" "$killseq"
        done | \
        sort -u | \
        _filter_SK
}

_duplicate() {
        sed -e 's/^.*$/&\t&/'
}

_format_status() {
	sed -e 's/^[[:space:]]*\([^[:space:]]\+\)[[:space:]]\+\(.*\)$/\2\t\1/'
}

_setup_filters() {
        [ -d $FILTERSDIR ] || return 0

        git ls-files $FILTERSDIR | while read f; do
                git config "filter.${f#$FILTERSDIR/}" "$f %f"
        done
}

_list_commits() {
	local br="${1-$(get_branch_name)}"
        local skip="${2-}"
	local limit="${3-}"

        [ $skip -eq 0 ] && skip=
        git log --format='%H%x09%ci%x09%s' ${skip:+--skip=$skip} ${limit:+-$limit} "$br"
}

list_commits() {
        local br="${1-${in_branch-$(get_branch_name)}}"
	local limit="${2-${in_limit-100}}"
        local skip="${3-${in_skip-0}}"

	(
		_cd_if_git /etc || return 0
		_list_commits "$br" "$skip" "$limit"
	)
}

_checkout_filters() {
        local br="$1"

        if [ -n "$(git ls-files --with-tree "$br" -- $FILTERSDIR 2>/dev/null)" ]; then
                git checkout --theirs $br -- $FILTERSDIR 1>/dev/null 2>&1
                return $?
        fi
}

_setup_branch_filters() {
        local br="$1"
        [ -n "$br" ] || return 0

        _checkout_filters "$br" && _setup_filters
}

_restore_filters() {
        rm -rf $FILTERSDIR
        if [ -n "$(git ls-files HEAD -- $FILTERSDIR 2>/dev/null)" ]; then
                git checkout HEAD -- $FILTERSDIR 1>/dev/null 2>&1 || return $?
                _setup_filters
        fi
}

_checkout_branch() {
	local br="${1-$(_get_branch_name)}"
        local mask="$(umask)"
        local ret=0

        umask 0027
        _setup_branch_filters "$br"
        ret=$?
        if [ $ret -eq 0 ]; then
                git checkout --force "$br" 1>/dev/null 2>&1
                ret=$?
        fi
        if [ $ret -eq 0 ] && [ -e $PERMS ]; then
                _apply_file_permissions <$PERMS
                ret=$?
        fi
        umask $mask 1>/dev/null 2>&1

        return $ret
}

checkout_branch() {
	local br="${1-${in_branch-$(get_branch_name)}}"

	(
		_cd_init /etc || return 1
		_checkout_branch "$br"
	)
}

reload_branch() {
	local br="${1-${in_branch-$(get_branch_name)}}"

	local srvs="$(_get_service_names_for_files $(list_modified_with_dirs "$br"))"
	local killseq="$(list_kill_seq "$srvs")"
	local startseq="$(list_start_seq "$srvs" "$killseq")"
	local ret=0

	for s in $killseq; do
		if ! service "$s" condstop >&2 && ! service "$s" stop >&2; then
                        printf '*** Unable to stop service: %s ***\n' "$s" >&2
			write_error_message "`_ 'Unable to stop service: %s'`" "$s"
			ret=1
			break
		fi
	done

	if [ $ret -eq 0 ]; then
	        echo "*** Checking out $br ***" >&2
		checkout_branch "$br"
		ret=$?
		if [ $ret -ne 0 ]; then
                        printf '*** Unable to checkout the configuration ***\n' >&2
                        write_error_message "`_ 'Unable to checkout the configuration'`"
                fi
	fi

	for s in $startseq; do
		if ! service "$s" start >&2; then
                        printf '*** Unable to start service: %s ***\n' "$s" >&2
			[ $ret -eq 0 ] && write_error_message "`_ 'Unable to start service: %s'`" "$s"
			ret=1
		fi
	done

	return $ret
}

_get_branch_head() {
	local br="${1-$(_get_branch_name)}"

        git show-ref --heads $br | sed -e 's,[[:space:]]\+refs/heads/.\+$,,'
}

get_branch_head() {
	local br="${1-${in_branch-$(get_branch_name)}}"

	(
		_cd_if_git /etc || return 0
		_get_branch_head "$br"
	)
}

_get_head_message() {
        local hd="${1-HEAD}"

        git log --format=%B -1 "$hd"
}

get_head_message() {
        local hd="${1-$in_head}"

        (
                _cd_if_git /etc || return 0
                _get_head_message "$hd"
        )
}

_get_diff() {
	local file="$1"
        local br="${2-$(_get_branch_name)}"

	if [ -n "$file" ]; then
                git add -f "$file" 1>/dev/null 2>&1
                git diff "$br" -- "$file" 2>/dev/null
                git reset "$file" 1>/dev/null 2>&1
	else
                _dump_file_permissions >$PERMS
                git add -f $PERMS 1>/dev/null 2>&1
                git diff "$br" 2>/dev/null
                git reset . 1>/dev/null 2>&1
	fi
}

get_diff() {
	local file="${1-${in_file-}}"
        local br="${2-${in_branch-$(get_branch_name)}}"

	(
		_cd_if_git /etc || return 0
		_get_diff "$file" "$br"
	)
}

_get_default_message() {
        echo "`_ 'Commit'`"
}

_commit_tree() {
        local msg="${1-$(_get_default_message)}"
        local nbr="${2-$(_get_branch_name)}"
        local br="$(_get_branch_name)"
        local ret=0

        if [ -n "$nbr" ] && [ -n "$br" ] && [ "$nbr" != "$br" ]; then
                git checkout -b "$nbr" 1>/dev/null 2>&1 || ret=1
                br="$nbr"
        fi
        if [ $ret -eq 0 ]; then
                if [ -e .gitignore ]; then
                        git add . 1>/dev/null 2>&1 || ret=3
                else
                        ret=2
                fi
        fi
        if [ $ret -eq 0 ]; then
                touch $PERMS
                git add -f $PERMS 1>/dev/null 2>&1 || ret=3
                if [ $ret -eq 0 ]; then
                        _dump_file_permissions >$PERMS || ret=4
                fi
        fi
        if [ $ret -eq 0 ]; then
                git add -f $PERMS 1>/dev/null 2>&1 || ret=3
        fi
        if [ $ret -eq 0 ]; then
                git commit -a -m "$msg" 1>/dev/null 2>&1 || ret=5
        fi
        if [ $ret -eq 0 ]; then
                if [ -z "$br" ] && [ -n "$nbr" ]; then
                        git branch -M "$(_get_branch_name)" "$nbr" 1>/dev/null 2>&1 || ret=1
                        br="$nbr"
                fi
        fi

        if [ $ret -eq 0 ]; then
                _publish_branch "$br" || ret=6
        fi

        return $ret
}

_publish_branch() {
        [ -d $PUBDIR ] || return 0
        local br="${1-$(_get_branch_name)}"
        [ -n "$br" ] || return 1

        case "$(_get_remote_branch_status $PUBDIR "$br")" in
                nw|ff)
                        git push $PUBDIR "$br" 1>/dev/null 2>&1 || return 4
                        ;;
                fr)
                        git push --force $PUBDIR "$br" 1>/dev/null 2>&1 || return 4
                        ;;
                lo|un)
                        git push $PUBDIR ":$br" 1>/dev/null 2>&1 || return 5
                        ;;
        esac
}

publish_branch() {
        [ -d $PUBDIR ] || return 0
        local br="${1-${in_branch-$(get_branch_name)}}"
        [ -n "$br" ] || return 1

        (
                _cd_if_git /etc || return 0
                _publish_branch "$br"
        )
}

_publish_repo() {
        [ -d $PUBDIR ] || return 0
        git show-ref --heads | sed -e 's,^[0-9a-z]\+[[:space:]]\+refs/heads/,,' | \
                while read br; do
                        _publish_branch "$br" || exit $?
                done
}

publish_repo() {
        [ -d $PUBDIR ] || return 0
        (
                _cd_if_git /etc || return 0
                _publish_repo
        )
}

init_pubdir() {
        local ret=0
        if ! [ -d $PUBDIR ]; then
                mkdir -p $PUBDIR
                git init --bare $PUBDIR 1>/dev/null 2>&1
                ret=$?
        fi

        return $ret
}

get_pubdir() {
        echo "$PUBDIR"
}

delete_pubdir() {
        [ -d $PUBDIR ] && rm -rf $PUBDIR
}

commit_tree() {
        local msg="${1-$in_msg}"
        local br="${2-${in_branch-$(get_branch_name)}}"
        local ret=

        (
	        _cd_if_git /etc || return 0
                _commit_tree "$msg" "$br"
                ret=$?
                case $ret in
                        1)
                                write_error_message "`_ 'Unable to create the new branch %s'`" "$br"
                                ;;
                        2)
                                write_error_message "`_ 'Unable to add files to the commit: the .gitignore file doesn'\''t exist'`"
                                ;;
                        3)
                                write_error_message "`_ 'Unable to add files to the commit'`"
                                ;;
                        4)
                                write_error_message "`_ 'Unable to add metadata to the commit'`"
                                ;;
                        5)
                                write_error_message "`_ 'Unable to commit changes locally'`"
                                ;;
                        6)
                                write_error_message "`_ 'Unable to commit changes to the public repository'`"
                                ;;
                        7)
                                write_error_message "`_ 'Unable to sync the local repository'`"
                                ;;
                esac

                [ $ret -eq 0 ]
        )
}

_() {
        echo "$1"
}

write_error() {
        echo "$1" >&2
}

write_error_message() {
	local msg="$(printf "$@")"
	write_error "$msg"
}
